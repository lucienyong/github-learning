1. 添加远程仓库  
在 GitHub 上创建的仓库路径为“git@github.com:用户名 \/git-tutorial.git”。现在我们用 git remote add命令将它设置成本地仓库的远程仓库。
```
$ git remote add origin git@github.com:lucienyong/DeepUnderstandingofEMF.git
```
按照上述格式执行 git remote add命令之后， Git 会自动将git@github.com:lucienyong/DeepUnderstandingofEMF.git远程仓库的名称设置为 origin（标识符）。  
2. 推送至远程仓库  
- 推送至 master 分支
如果想将当前分支下本地仓库中的内容推送给远程仓库，需要用到git push命令。
通常情况下只需要git push就可以了。但如果万一master丢失了，该怎么办呢？
```
$ git push
fatal: The current branch master has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin master
```
上面的显示信息同时给出了一种办法。
```
$ git push --set-upstream origin master
Enumerating objects: 8, done.
Counting objects: 100% (8/8), done.
Delta compression using up to 8 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 589 bytes | 117.00 KiB/s, done.
Total 6 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
remote:
remote: Create a pull request for 'master' on GitHub by visiting:
remote:      https://github.com/lucienyong/DeepUnderstandingofEMF/pull/new/master
remote:
To github.com:lucienyong/DeepUnderstandingofEMF.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.
```
- 推送至 master 以外的分支
除了 master 分支之外，远程仓库也可以创建其他分支。举个例子，我们在本地仓库中创建 2.Practice 分支，并将它以同名形式 push 至远程仓库。
但由于远程仓库已经有了2.Practice的分支，而本地只是刚刚创建此分支，所以要使用git pull命令将远程和本地进行同步。
```
$ git pull origin 2.Practice
remote: Enumerating objects: 13, done.
remote: Counting objects: 100% (13/13), done.
remote: Compressing objects: 100% (11/11), done.
remote: Total 11 (delta 5), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (11/11), 4.13 KiB | 44.00 KiB/s, done.
From github.com:lucienyong/github-learning
 * branch            2.Practice -> FETCH_HEAD
   7b82882..33f7393  2.Practice -> origin/2.Practice
Merge made by the 'recursive' strategy.
 ...205\254\345\274\200\344\273\243\347\240\201.md" | 80 ++++++++++++++++++++++
 Readme.md                                          |  3 +-
 2 files changed, 82 insertions(+), 1 deletion(-)
 create mode 100644 "3.\345\205\254\345\274\200\344\273\243\347\240\201.md"
```
GitHub 端远程仓库中的 2.Practice 分支是最新状态，所以本地仓库中的 2.Practice 分支就得到了更新。今后只需要像平常一样在本地进行提交再 push 给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，不断给 2.Practice 增加新功能。
如果两人同时修改了同一部分的源代码， push 时就很容易发生冲突。所以多名开发者在同一个分支中进行作业时，为减少冲突情况的发生，建议更频繁地进行 push 和 pull 操作。
```
$ git push -u origin 2.Practice
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 8 threads
Compressing objects: 100% (5/5), done.
Writing objects: 100% (5/5), 4.04 KiB | 1.35 MiB/s, done.
Total 5 (delta 2), reused 0 (delta 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To github.com:lucienyong/github-learning.git
   33f7393..8ed042d  2.Practice -> 2.Practice
Branch '2.Practice' set up to track remote branch '2.Practice' from 'origin'.
```  
3. 获取远程仓库  
首先我们换到其他目录下，将 GitHub 上的仓库 clone 到本地。注意不要与之前操作的仓库在同一目录下。
```
$ git clone git@github.com:github-book/git-tutorial.git
Cloning into 'git-tutorial'...
remote: Counting objects: 20, done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 20 (delta 3), reused 20 (delta 3)
Receiving objects: 100% (20/20), done.
Resolving deltas: 100% (3/3), done.
$ cd git-tutorial
```
执行 git clone命令后我们会默认处于 master 分支下，同时系统会自动将 origin 设置成该远程仓库的标识符。也就是说，当前本地仓库的 master 分支与 GitHub 端远程仓库（origin）的 master 分支在内容上是完全相同的。
```
$ git branch -a
* master
remotes/origin/HEAD -> origin/master
remotes/origin/feature-D
remotes/origin/master
```
我们用 git branch -a命令查看当前分支的相关信息。添加 -a参数可以同时显示本地仓库和远程仓库的分支信息。结果中显示了 remotes/origin/feature-D，证明我们的远程仓库中已经有了 feature-D 分支。
**这个远程仓库当然是可访问的，不是一个陌生人的，是我们自己的。**
如果随便从网上clone一个仓库，修改后提交给此被clone的仓库，对方肯定是拒绝的。
```
$ git push
ERROR: Permission to github-book/git-tutorial.git denied to lucienyong.
fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
```
这就好比通过某种方式得到了对方的手机号码，如果强行给对方打电话，对方肯定是拒接的。
我们试着将 feature-D 分支获取至本地仓库。
```
$ git checkout -b feature-D origin/feature-D
Branch feature-D set up to track remote branch feature-D from origin.
Switched to a new branch 'feature-D'
```
-b 参数的后面是本地仓库中新建分支的名称。为了便于理解，我们仍将其命名为 feature-D，让它与远程仓库的对应分支保持同名。新建分支名称后面是获取来源的分支名称。例子中指定了 origin/feature-D，就是说以名为 origin 的仓库（这里指 GitHub 端的仓库）的 feature-D 分支为来源，在本地仓库中创建 feature-D 分支。
现在假定我们是另一名开发者，要做一个新的提交。在 README.md 文件中添加一行文字，查看更改。**其实就是一个账户，多人使用。**
```
$ git diff
diff --git a/README.md b/README.md
index af647fd..30378c9 100644
--- a/README.md
+++ b/README.md
@@ -3,3 +3,4 @@
- feature-A
- fix-B
- feature-C
+ - feature-D
```
然后提交。
```
$ git commit -am "Add feature-D"
[feature-D ed9721e] Add feature-D
1 file changed, 1 insertion(+)
```
再来推送 feature-D 分支。
```
$ git push
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 281 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
To git@github.com:github-book/git-tutorial.git
ca0f98b..ed9721e feature-D -> feature-D
```
从远程仓库获取 feature-D 分支，在本地仓库中提交更改，再将feature-D 分支推送回远程仓库，通过这一系列操作，就可以与其他开发者相互合作，共同培育 feature-D 分支，实现某些功能。
